#!/usr/bin/env python

""" Various custom AST node types that contain LLVM code generation methods. """

import antlr3
import antlr3.tree
from llvm.core import Module, Constant, Type, Value, Function, Builder, FCMP_ULT

from simpleLexer import *

# GLOBALS (directly from tutorials)
g_llvm_builder = None  # Builder created any time a function is entered.
tp_int = Type.int()
tp_bool = Type.int(1)


class EmitNode(antlr3.tree.CommonTree):
    def __str__(self):
        return str(self.emit())

    def emit(self):
        print "TYPE " + str(self.type) + " UNIMPLEMENTED"

    def getScope(self):
        """
        This will return the nearest BLOCK's scope. This is useful for updating
        a blocks scope from assignments.
        :rtype: dict[str, Value]
        """
        return self.parent.getScope()

    def getClosure(self):
        """
        Only Block nodes have variable scopes. Default behavior is to just ask
        for the parents closure. The root of the AST will always be a BLOCK, so
        it should always return from there.
        :rtype: dict[str, Value]
        """
        return self.parent.getClosure()


class BlockNode(EmitNode):
    def __init__(self, payload):
        super(BlockNode, self).__init__(payload)

        self.scope = {}
        """ The local scope for this block. """

        self.closure = []
        """ :type : list[dict] """

        if self.parent is not None:
            # Use list() to create a new list rather than updating the parent's.
            self.closure = list(self.parent.getClosure()).append(self.scope)
        else:
            self.closure.append(self.scope)

    def __str__(self):
        return '\n'.join([str(node) for node in self.children])

    def emit(self):
        for child in self.children:
            child.emit()
            # NOTE: Blocks do not have a return value!

    def getScope(self):
        return self.scope

    def getClosure(self):
        return self.closure


class SkipNode(EmitNode):
    def __str__(self):
        return "SKIP"

    def emit(self):
        # Emit useless instruction as a no-op.
        zero = Constant.int(tp_int, 0)
        return g_llvm_builder.add(zero, zero, "noop")


class IntegerNode(EmitNode):
    def __str__(self):
        return self.text

    def emit(self):
        return Constant.int(tp_int, self.text)


class IdentifierNode(EmitNode):
    def __str__(self):
        return self.text

    def emit(self):
        name = self.text
        scope = [scope for scope in self.getClosure() if name in scope]
        if scope:
            scope = scope[0]
            return g_llvm_builder.load(scope[name], name)
        else:
            raise RuntimeError("Unknown variable name: " + self.text)


class UnaryNode(EmitNode):
    def __str__(self):
        return "".join(self.children)

    def emit(self):
        op = self.children[0]
        expr = self.children[1].emit()
        if op.text == '-':
            return g_llvm_builder.neg(expr, "negated_" + expr.name)
        else:
            return expr


class BooleanNode(EmitNode):
    def __str__(self):
        return self.text

    def emit(self):
        if self.text.lower() == "true":
            return Constant.int(tp_bool, 1)
        elif self.text.lower() == "false":
            return Constant.int(tp_bool, 0)
        else:
            raise RuntimeError("Invalid boolean value.")


class UnaryBoolOpNode(EmitNode):
    def emit(self):
        b = self.children[0]
        return g_llvm_builder.not_(b, "notbool")


class BinaryBoolOpNode(EmitNode):
    def emit(self):
        left = self.children[0].emit()
        right = self.children[1].emit()

        if self.text.lower() == '&':
            return g_llvm_builder.and_(left, right, "and")
        elif self.text.lower() == '|':
            return g_llvm_builder.or_(left, right, "or")
        else:
            raise RuntimeError("Unrecognized binary boolean operator.")


class AssignmentNode(EmitNode):
    def emit(self):
        name = self.children[0].text
        val = self.children[1].emit()

        # Find scope this variable exists in (if it exists already). If not,
        #  add the variable name to the current scope and allocate it.
        scope = [scope for scope in self.getClosure() if name in scope]
        if scope:
            scope = scope[0]  # Remove outer list generated by list comp.
        else:
            scope = self.getScope()
            scope[name] = g_llvm_builder.alloca(tp_int, name=name)

        # Update the value of the variable.
        return g_llvm_builder.store(val, scope[name])


class ArithmeticNode(EmitNode):
    def emit(self):
        left = self.children[0].emit()
        right = self.children[1].emit()

        if self.text == '*':
            return g_llvm_builder.mul(left, right, 'mul')
        elif self.text == '+':
            return g_llvm_builder.add(left, right, 'add')
        elif self.text == '-':
            return g_llvm_builder.sub(left, right, 'sub')
        else:
            raise RuntimeError("Unrecognized arithmetic operator.")


class RelationalNode(EmitNode):
    def emit(self):
        children = self.getChildren()
        left = children[0].emit()
        right = children[1].emit()

        if self.getText() == '=':
            return left + ' = ' + right
        elif self.getText() == '<':
            return left + ' < ' + right
        elif self.getText() == '<=':
            return left + ' <= ' + right
        elif self.getText() == '>':
            return left + ' > ' + right
        elif self.getText() == '>=':
            return left + ' >= ' + right
        else:
            raise Exception("Unrecognized relational operator.")


class IfElseThenNode(EmitNode):
    def emit(self):
        temp = ""  # TODO: TEMP VAR FOR STRING RETURN DEBUGGING
        children = self.getChildren()
        conditional = children[0]
        then_branch = children[1]
        else_branch = children[2]

        # Convert conditional to a boolean.
        conditional_bool = "conditional_bool = [" + str(
            conditional) + " == 0.0]"
        temp = '\n'.join([temp, conditional_bool])

        # Create blocks for the if/then cases.
        # TODO: Create branch function
        then_block = ""
        else_block = ""
        merge_block = ""

        # Emit conditional instruction.
        temp = '\n'.join([temp, "if conditional_bool GOTO THEN else GOTO ELSE"])

        # Emit THEN instructions at end of ELSE block.
        then_block = then_block + then_branch.emit()
        temp = '\n'.join([temp, then_block])
        temp = '\n'.join([temp, "GOTO merge block"])

        # Emitting then can change block, update then block to the block the
        # builder is currently in (for the Phi function).
        # TODO: Set then_block to current block

        # Emit ELSE instructions at end of ELSE block.
        else_block = else_block + else_branch.emit()
        temp = '\n'.join([temp, else_block])
        temp = '\n'.join([temp, "GOTO merge block"])

        # Emitting else can change block, update else block to the block the
        # builder is currently in (for the Phi function).
        # TODO: Set else_block to current block

        # Emit merge block.
        # TODO: Create phi node

        # TODO: return phi
        return temp


class WhileNode(EmitNode):
    def emit(self):
        return '\n'.join([str(node) for node in self.getChildren()])


class ErrorNode(antlr3.tree.CommonErrorNode):
    def emit(self):
        raise RuntimeError("Could not parse input:\n\n    " + self.getText())


class LlvmAdaptor(antlr3.tree.CommonTreeAdaptor):
    def createWithPayload(self, payload):
        if payload is None:
            return EmitNode(payload)

        # Fixes the problem where ANTLR3 produces Unicode objects instead of
        # Python string objects, and LLVM does not like Unicode objects.
        payload.text = str(payload.text)

        t = payload.type
        if t == BLOCK:
            return BlockNode(payload)
        if t == SKIP:
            return SkipNode(payload)
        elif t == INTEGER:
            return IntegerNode(payload)
        elif t == IDENT:
            return IdentifierNode(payload)
        elif t == UNARY:
            return UnaryNode(payload)
        elif t in (MULT, PLUS, MINUS):
            return ArithmeticNode(payload)
        elif t == RELOP:
            return RelationalNode(payload)
        elif t == BOOLEAN:
            return BooleanNode(payload)
        elif t == NOT:
            return UnaryBoolOpNode(payload)
        elif t in (AND, OR):
            return BinaryBoolOpNode(payload)
        elif t == GETS:
            return AssignmentNode(payload)
        elif t == IF:
            return IfElseThenNode(payload)
        elif t == WHILE:
            return WhileNode(payload)
        else:
            return EmitNode(payload)

    def errorNode(self, input, start, stop, exc):
        return ErrorNode(input, start, stop, exc)